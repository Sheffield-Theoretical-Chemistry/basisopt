# molecule
import numpy as np
from .exceptions import InvalidDiatomic

class Molecule:
    def __init__(self, name="Untitled", charge=0, mult=1):
        self.name = name
        self.charge = charge
        self.multiplicity = mult
        self.method = ""
        self.basis = {}
        self._atom_names = []
        self._coords = []
        self._results = {}
        self._references = {}
        
    def add_atom(self, element='H', coord=[0.0, 0.0, 0.0]): 
        self._coords.append(np.array(coord))
        self._atom_names.append(element)
    
    def add_result(self, name, value):
        self._results[name] = value
        
    def get_result(self, name):
        try:
            return self._results[name]
        except KeyError:
            return 0.0
            
    def add_reference(self, name, value):
        self._references[name] = value
        
    def get_reference(self, name):
        try:
            return self._references[name]
        except KeyError:
            return 0.0        
    
    def get_delta(self, name):
        return (self.get_result(name) - self.get_reference(name))
    
    def from_xyz(self, filename): 
        try:
            f = open(filename, 'r')
            lines = f.readlines()
            # first line should be natoms
            nat = int(lines[0])
            # second line is title
            for line in lines[2:2+nat]:
                words = line.split()
                element = words[0]
                coords = np.array([float(w) for w in words[1:4]])
                self.add_atom(element=element, coord=coords)
        except IOError as e:
            print(f"I/O error({e.errno}): {e.strerror}")
        except:
            print(f"Incorrect formatting in {filename}")
        
    def to_xyz(self):
        output = f"{self.natoms()}\n{self.name}, generated by BasisOpt"
        for n, c in zip(self._atom_names, self._coords):
            output += f"\n{n}\t{c[0]}\t{c[1]}\t{c[2]}"
        return output
    
    def get_line(self, i):
        ix = max(i, 0)
        ix = min(i, len(self._atom_names)-1)
        n, c = self._atom_names[ix], self._coords[ix]
        return f"{n}\t{c[0]}\t{c[1]}\t{c[2]}"
        
    def natoms(self):
        return len(self._atom_names)
        
    def unique_atoms(self):
        return list(set(self._atom_names))
        
    def distance(self, atom1, atom2):
        c1 = self._coords[atom1]
        c2 = self._coords[atom2]
        return np.linalg.norm(c1 - c2)
        
def build_diatomic(mol_str, charge=0, mult=1):
    molecule = Molecule(name=mol_str+"_Dunham", charge=charge, mult=mult)
    # parse the mol string, form "Atom1Atom2,Separation(ang)"
    parts = mol_str.split(',')
    chars = list(parts[0])
    rval = float(parts[1])
    nchars = len(chars)
    if nchars == 2:
        # either something like NO or N2
        if chars[1] == '2':
            atom1 = atom2 = chars[0]
        else:
            atom1 = chars[0]
            atom2 = chars[1]
    elif nchars==3:
        if chars[2] == '2':
            atom1 = atom2 = "".join(chars[:2])
        elif chars[1].isupper():
            atom1 = chars[0]
            atom2 = "".join(chars[1:])
        else:
            atom1 = "".join(chars[:2])
            atom2 = chars[2]
    elif nchars==4:
        atom1 = "".join(chars[:2])
        atom2 = "".join(chars[2:4])
    else:
        raise InvalidDiatomic
    
    molecule.add_atom(element=atom1, coord=[0.0, 0.0, -0.5*rval])
    molecule.add_atom(element=atom2, coord=[0.0, 0.0,  0.5*rval])
    return molecule
        